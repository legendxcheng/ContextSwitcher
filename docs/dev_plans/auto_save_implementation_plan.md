# 任务自动保存功能实施计划

## 📋 项目信息
- **计划版本**: v1.0
- **创建日期**: 2025-11-04
- **问题描述**: 任务数据仅在程序退出时保存，导致用户修改的任务在某些情况下无法持久化
- **目标**: 实现任务变更时的实时自动保存机制

---

## 🔍 问题根源分析

### 当前数据流程

```
启动程序
  ↓
加载 tasks.json
  ↓
运行主窗口
  ↓
用户操作（添加/编辑/删除任务）
  ↓
点击 X 关闭窗口
  ↓
触发 WIN_CLOSED 事件
  ↓
main_window.close() 调用 on_window_closed()
  ↓
ContextSwitcher.cleanup() 保存数据 ← 唯一保存点
  ↓
程序退出
```

### 风险点识别

| 风险场景 | 影响 | 发生概率 |
|---------|------|---------|
| 程序异常崩溃 | 数据完全丢失 | 低 |
| cleanup() 执行失败 | 数据未保存 | 中 |
| 多次调用cleanup导致覆盖 | 保存错误数据 | 低 |
| 磁盘写入失败但无提示 | 用户不知道未保存 | 中 |
| 编译版本退出流程异常 | 数据未保存 | **高** ⚠️ |

### 核心问题

**当前架构的致命缺陷**：
- ❌ 所有修改操作在内存中累积，直到程序退出才一次性保存
- ❌ 没有任何中间保存点
- ❌ 如果保存失败，用户无法得知，且无法恢复

---

## 🎯 解决方案：实时自动保存

### 设计原则

1. **即时性**: 任何数据变更后立即保存
2. **安全性**: 保留退出时的最终保存作为双重保险
3. **透明性**: 保存失败时明确提示用户
4. **非侵入性**: 不影响现有代码结构和用户体验

### 架构设计

```
任务变更操作（添加/编辑/删除/状态更新）
  ↓
触发 TaskManager 回调
  ↓
ActionDispatcher.on_task_changed()
  ↓
【新增】立即调用自动保存
  ↓
DataStorage.save_tasks()
  ↓
成功 → 静默继续 | 失败 → 显示警告
```

---

## 📝 详细实施检查清单

### 阶段1：架构准备（3项）

- [ ] **1.1 建立 DataStorage 引用传递机制**
  - 目标：让 MainWindow 和 ActionDispatcher 能够访问 DataStorage
  - 修改文件：`gui/main_window.py`, `gui/action_dispatcher.py`
  - 实现方式：在 MainWindow 初始化时接收 data_storage 参数，并传递给 ActionDispatcher
  - 验证标准：ActionDispatcher 能成功调用 data_storage.save_tasks()

- [ ] **1.2 扩展 IActionProvider 接口**
  - 目标：在接口中添加获取 DataStorage 的方法
  - 修改文件：`gui/action_dispatcher.py` (IActionProvider 接口定义)
  - 新增方法：`get_data_storage() -> DataStorage`
  - 验证标准：接口定义完整，类型提示正确

- [ ] **1.3 更新 MainWindow 的 IActionProvider 实现**
  - 目标：实现新增的接口方法
  - 修改文件：`gui/main_window.py`
  - 新增实现：
    ```python
    def get_data_storage(self):
        """获取数据存储管理器 - IActionProvider接口实现"""
        return self.data_storage
    ```
  - 验证标准：MainWindow 满足完整的 IActionProvider 接口

---

### 阶段2：自动保存核心功能（4项）

- [ ] **2.1 实现 ActionDispatcher 的自动保存方法**
  - 目标：创建线程安全的自动保存功能
  - 修改文件：`gui/action_dispatcher.py`
  - 新增方法：`_auto_save_tasks()`
  - 功能要点：
    - 获取当前所有任务
    - 调用 DataStorage.save_tasks()
    - 捕获并处理所有异常
    - 记录保存成功/失败日志
  - 验证标准：方法能够安全调用，不会抛出未捕获异常

- [ ] **2.2 在 on_task_changed 回调中集成自动保存**
  - 目标：任务变更时自动触发保存
  - 修改文件：`gui/action_dispatcher.py` (on_task_changed 方法)
  - 修改位置：在 `self.update_display()` 之后添加自动保存调用
  - 触发场景：
    - 添加任务 (on_task_added)
    - 删除任务 (on_task_removed)
    - 编辑任务 (on_task_updated)
  - 验证标准：每次任务变更后都会自动保存

- [ ] **2.3 实现保存失败的用户提示机制**
  - 目标：保存失败时通过状态栏提示用户
  - 修改文件：`gui/action_dispatcher.py`
  - 实现方式：在 `_auto_save_tasks()` 中，失败时调用 `self.set_status("⚠️ 自动保存失败", 5000)`
  - 验证标准：人为制造保存失败情况时，用户能看到警告

- [ ] **2.4 添加保存防抖机制（可选优化）**
  - 目标：防止短时间内多次保存造成性能问题
  - 修改文件：`gui/action_dispatcher.py`
  - 实现方式：
    - 记录上次保存时间戳
    - 如果距离上次保存不足1秒，跳过本次保存
    - 使用定时器延迟保存
  - 验证标准：连续快速操作时不会导致卡顿

---

### 阶段3：Main.py 集成（2项）

- [ ] **3.1 修改 ContextSwitcher.initialize_components()**
  - 目标：将 DataStorage 传递给 MainWindow
  - 修改文件：`main.py`
  - 修改位置：MainWindow 初始化代码
  - 修改前：
    ```python
    self.main_window = MainWindow(self.task_manager)
    ```
  - 修改后：
    ```python
    self.main_window = MainWindow(self.task_manager, self.data_storage)
    ```
  - 验证标准：程序能正常启动

- [ ] **3.2 保留退出时的最终保存（双重保险）**
  - 目标：确保 cleanup() 中的保存逻辑依然执行
  - 修改文件：`main.py` (cleanup 方法)
  - 保持现有逻辑不变
  - 验证标准：退出时仍然会执行一次完整保存

---

### 阶段4：增强日志和监控（2项）

- [ ] **4.1 增强保存日志输出**
  - 目标：便于调试和问题追踪
  - 修改文件：`gui/action_dispatcher.py`, `utils/data_storage.py`
  - 新增日志内容：
    - `[AutoSave] 检测到任务变更，准备自动保存...`
    - `[AutoSave] 成功保存 N 个任务（耗时 X ms）`
    - `[AutoSave] 保存失败: 错误信息`
  - 验证标准：在控制台能清晰看到所有保存操作

- [ ] **4.2 添加保存统计信息**
  - 目标：监控自动保存功能运行状况
  - 修改文件：`gui/action_dispatcher.py`
  - 新增属性：
    ```python
    self.auto_save_count = 0  # 自动保存次数
    self.auto_save_fail_count = 0  # 失败次数
    self.last_auto_save_time = 0  # 上次保存时间
    ```
  - 验证标准：可通过 get_status_info() 查看统计信息

---

### 阶段5：错误处理和边界情况（3项）

- [ ] **5.1 处理 DataStorage 为 None 的情况**
  - 目标：防止空指针异常
  - 修改文件：`gui/action_dispatcher.py`
  - 实现方式：在 `_auto_save_tasks()` 开头检查 data_storage 是否存在
  - 验证标准：即使 data_storage 未初始化，也不会崩溃

- [ ] **5.2 处理磁盘空间不足的情况**
  - 目标：优雅处理磁盘满的错误
  - 修改文件：`utils/data_storage.py` (save_tasks 方法)
  - 实现方式：捕获 OSError，返回 False 并记录错误
  - 验证标准：磁盘满时不会崩溃，并提示用户

- [ ] **5.3 处理保存权限不足的情况**
  - 目标：检测并提示权限问题
  - 修改文件：`utils/data_storage.py` (save_tasks 方法)
  - 实现方式：捕获 PermissionError，记录详细错误信息
  - 验证标准：权限不足时有明确的错误提示

---

### 阶段6：测试和验证（5项）

- [ ] **6.1 单元测试：自动保存功能**
  - 创建测试文件：`tests/test_auto_save.py`
  - 测试场景：
    - 添加任务后自动保存
    - 编辑任务后自动保存
    - 删除任务后自动保存
    - 保存失败时的错误处理
  - 验证标准：所有测试通过

- [ ] **6.2 集成测试：完整数据持久化流程**
  - 测试步骤：
    1. 启动程序
    2. 添加任务 A
    3. 检查 tasks.json 是否包含任务 A
    4. 编辑任务 A
    5. 检查 tasks.json 是否更新
    6. 关闭程序（不等待退出保存）
    7. 重新启动
    8. 验证任务 A 的修改是否保留
  - 验证标准：所有步骤数据一致

- [ ] **6.3 压力测试：快速连续操作**
  - 测试步骤：
    1. 快速连续添加10个任务
    2. 快速连续编辑所有任务
    3. 检查是否所有修改都被保存
  - 验证标准：不丢失任何修改，不出现卡顿

- [ ] **6.4 异常测试：模拟保存失败**
  - 测试方法：
    - 临时删除 data 目录的写权限
    - 执行任务操作
    - 观察错误提示和程序稳定性
  - 验证标准：程序不崩溃，有明确错误提示

- [ ] **6.5 用户验收测试：实际使用场景**
  - 测试步骤：
    1. 使用编译后的 exe 运行
    2. 执行日常任务管理操作
    3. 点击 X 关闭
    4. 重新打开验证数据
  - 验证标准：用户确认问题已解决

---

### 阶段7：文档和部署（3项）

- [ ] **7.1 更新开发文档**
  - 文件位置：`docs/AUTO_SAVE_FEATURE.md`
  - 内容包括：
    - 自动保存机制说明
    - 保存触发时机
    - 错误处理流程
    - 性能影响分析
  - 验证标准：文档完整清晰

- [ ] **7.2 重新编译 exe 程序**
  - 执行命令：`build.bat`
  - 测试编译后的程序功能
  - 验证标准：编译成功，功能正常

- [ ] **7.3 备份现有数据**
  - 操作步骤：
    1. 备份 `dist/data/tasks.json`
    2. 备份 `dist/data/backups/` 目录
    3. 创建恢复说明文档
  - 验证标准：数据安全备份

---

## 📊 代码修改文件清单

| 文件路径 | 修改类型 | 预估行数 | 风险等级 |
|---------|---------|---------|---------|
| `gui/action_dispatcher.py` | 新增+修改 | +50行 | 低 |
| `gui/main_window.py` | 修改 | +10行 | 低 |
| `main.py` | 修改 | +5行 | 低 |
| `utils/data_storage.py` | 增强 | +20行 | 低 |
| `tests/test_auto_save.py` | 新增 | +150行 | - |
| `docs/AUTO_SAVE_FEATURE.md` | 新增 | - | - |

**总计**: 约 235 行代码修改/新增

---

## ⏱️ 时间估算

| 阶段 | 预估时间 | 累计时间 |
|-----|---------|---------|
| 阶段1: 架构准备 | 30分钟 | 30分钟 |
| 阶段2: 自动保存核心功能 | 1小时 | 1.5小时 |
| 阶段3: Main.py 集成 | 15分钟 | 1小时45分钟 |
| 阶段4: 增强日志和监控 | 30分钟 | 2小时15分钟 |
| 阶段5: 错误处理和边界情况 | 45分钟 | 3小时 |
| 阶段6: 测试和验证 | 1.5小时 | 4.5小时 |
| 阶段7: 文档和部署 | 30分钟 | 5小时 |

**总预估时间**: 5小时

---

## 🎯 成功标准

### 功能性标准
- ✅ 任何任务变更后立即自动保存
- ✅ 保存失败时有明确提示
- ✅ 程序退出时仍然执行最终保存
- ✅ 所有测试用例通过

### 性能标准
- ✅ 自动保存操作不超过 50ms
- ✅ 不影响 UI 响应速度
- ✅ 不引起明显的磁盘 I/O 峰值

### 用户体验标准
- ✅ 用户无需关心保存问题
- ✅ 数据永不丢失
- ✅ 保存过程完全透明
- ✅ 失败时有清晰的错误提示

---

## 🚨 风险评估与应对

| 风险 | 影响 | 概率 | 应对措施 |
|-----|------|------|---------|
| 频繁保存导致性能下降 | 中 | 低 | 实施防抖机制，限制保存频率 |
| 保存操作阻塞 UI 线程 | 高 | 低 | 使用异步保存（如果必要） |
| 多次保存导致备份文件过多 | 低 | 中 | 只在退出时创建备份，运行时直接覆盖 |
| 兼容性问题（旧版本数据） | 中 | 低 | 保留现有的数据版本兼容逻辑 |
| 编译版本行为与开发版本不一致 | 高 | 低 | 充分测试编译后的 exe |

---

## 📌 备注

### 关键设计决策

1. **为什么选择同步保存而非异步？**
   - 数据量小（通常不超过10个任务）
   - 保存操作快速（< 10ms）
   - 避免异步带来的复杂性和潜在的数据竞争

2. **为什么保留退出时的保存？**
   - 双重保险机制
   - 向后兼容
   - 捕获可能遗漏的变更

3. **为什么不使用数据库？**
   - JSON 文件足够简单
   - 便于用户手动查看和编辑
   - 不引入额外依赖

### 后续优化方向

- [ ] 实现配置项控制是否启用自动保存
- [ ] 添加保存队列，批量处理连续的保存请求
- [ ] 实现保存进度提示（对于大量任务）
- [ ] 添加数据导入导出功能

---

## ✅ 计划审批

**计划制定人**: AI Assistant  
**计划审批人**: 用户  
**制定日期**: 2025-11-04  
**预期开始日期**: 待用户批准  

---

**等待用户批准此计划后进入执行模式 (EXECUTE)**


